{-# OPTIONS_GHC -Wno-unused-matches #-}
{-# OPTIONS_GHC -Wno-unused-top-binds #-}

module LazyEvaluation (lazyEvaluation) where

lazyEvaluation :: IO ()
lazyEvaluation = putStrLn "-- Lazy Evaluation --"

-- * 遅延評価 (lazy evaluation)

{-
Haskellは基本的に遅延評価を採用している。
遅延評価は、必要になるまで式の評価を遅らせる手法である。
(したがって、評価する必要のない式は一切評価されない)

遅延評価は非正格評価の一種であり、正格評価とは異なる性質を持つ。
-}

-- 遅延評価の例
-- ex) if式をラップしたif'関数で考える
-- 以下のような関数定義を考える。
-- if' b x y = if b then x else y

-- if' (1 < 2) (3 * 4) (5 * 6) を評価する。

-- ** 正格評価の場合

{-
if' (1 < 2) (3 * 4) (5 * 6)
= if' True 12 30 -- 全ての引数を最初に評価する
= if True then 12 else 30
= 12
-}

-- ** 非正格評価の場合

{-
if' (1 < 2) (3 * 4) (5 * 6)
= if 1 < 2 then 3 * 4 else 5 * 6 -- 引数を評価しないまま関数定義を展開する
= if True then 3 * 4 else 5 * 6
= 3 * 4 -- 5 * 6 は評価されない
= 12
-}

-- 無限リスト
{-
Haskellでは無限リストに関数を適用してもプログラムが正常に動作する理由は、
遅延評価によって説明できる。

take 3 [1..]
= 1 : take 2 [2..]
= 1 : 2 : take 1 [3..]
= 1 : 2 : 3 : take 0 [4..]
= 1 : 2 : 3 : []
= [1, 2, 3]
-}

-- * 正格評価の利用

{-
Haskellは、基本的に遅延評価だが、意図的に正格評価を利用することもできる。
-}

-- ** seq :: a -> b -> b の利用 (seq関数の利用)

{-
x `seq` y は、式xを評価した後に式yを評価する。
-}

-- 非正格評価をするif式のラッパー関数
if' :: Bool -> p -> p -> p
if' b x y = if b then x else y

-- 正格評価をするif式のラッパー関数
if'' :: Bool -> p -> p -> p
if'' b x y = b `seq` x `seq` y `seq` if b then x else y

{-
以下のような場合を考える。

-- 非正格評価の場合
-- else節の (1 `div` 0) は評価されないために、例外は発生しない。
if' True 1 (1 `div` 0) -- output: 1

-- 正格評価の場合
-- if''関数が始めに全ての引数を評価するため、
-- else節の (1 `div` 0) が評価されることによって例外が発生する。
if'' True 1 (1 `div` 0) -- 例外発生
-}

-- **  $! 演算子

{-
  $! 演算子は、引数を正格評価するための演算子である。
  $! 演算子は $ 演算子のバリアントになっている。

  -- 定義
  -- 関数と引数を1つ受け取って、関数に色数を適用した結果を返す。
  ($!) ：： (a -> b) -> a -> b
  -- x `seq` f x について
  -- 引数を最初に評価してしまってから、関数を適用するということを意味する。
  f $! x = x `seq` f x

square x = x * x が定義されていたとき、以下の式を考える。

-- ** 非正格評価の場合
square $ square $ 1 + 2
= square $ square (1 + 2)
= square (square (1 + 2))
= square (1 + 2) * square (1 + 2)
= ((1 + 2) * (1 + 2)) * ((1 + 2) * (1 + 2))
= 81

-- ** 正格評価の場合
square $! square $! 1 + 2
= square $! square 3
= square $! 3 * 3
= square $! 9
= 9 * 9
= 81
-}

-- ** 正格性フラグ !

{-
Haskellでは、データ構造も遅延性を持つため、
フィールドは必要になるまで評価されない。
data宣言時に正格性フラグ ! を各フィールドに付与することで、
そのフィールドを正格評価することができる。
-}

-- 非正格評価が行われるデータ型
data Tuple a b = T a b

-- 正格評価が行われるデータ型
data Tuple' a b = T' !a !b

-- 先程定義した型構成子の一つ目の要素を取得する関数を定義する。
fst :: Tuple a b -> a
fst (T x y) = x

fst' :: Tuple' a b -> a
fst' (T' x y) = x

{-
以下のような場合を考える。

-- 非正格評価の場合
-- (1 `div` 0) は評価されないために、例外は発生しない。
fst $ T 'a' (1 `div` 0) -- output: 'a'

-- 正格評価の場合
-- fst'関数が始めに (正格性フラグを付けたフィールドに限り)
-- 全ての引数を評価するため、(1 `div` 0) が評価される
-- ことによって例外が発生する。
fst' $ T 'a' (1 `div` 0) -- 例外発生
-}